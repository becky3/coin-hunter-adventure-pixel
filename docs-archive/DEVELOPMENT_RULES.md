# coin-hunter-adventure-pixel 開発ルール

このドキュメントは、プロジェクトの進め方、作業フロー、Git運用などの開発プロセスに関するルールを定めています。

## 1. プロジェクト構成

### リポジトリ管理
- **メインリポジトリ**: `/coin-hunter-adventure-pixel/` - 新規開発用
- **参照用アーカイブ**: `/old_project_achive/testAction/` - 読み取り専用（参照のみ）

### 関連ドキュメント
- **コーディング規約**: `CODING_STANDARDS.md` - コードの書き方、命名規則
- **アーキテクチャ**: `ARCHITECTURE.md` - ディレクトリ構造、設計方針
- **引き継ぎ資料**: `handover-docs/` フォルダ内 - 作業の引き継ぎ資料

### 日付の記載ルール
- **フォーマット**: `YYYY-MM-DD` 形式（例: 2025-06-24）
- **タイムゾーン**: JST（日本標準時）
- **ファイル名**: 引き継ぎ資料は `handover-docs/YYYY-MM-DD_作業内容.md` 形式で保存

## 2. Git運用ルール

### ブランチ戦略
```
main                    # 本番環境
├── develop            # 開発統合ブランチ  
│   ├── feature/xxx    # 機能開発
│   └── bugfix/xxx     # バグ修正
└── release/v1.0       # リリース準備
```

### ブランチ作成のルール
**重要**: mainブランチへの直接プッシュは禁止です。

1. **必ずfeatureブランチを作成してから作業を開始**
   ```bash
   git checkout -b feature/機能名
   ```

2. **作業の流れ**
   - featureブランチで開発・コミット
   - プッシュしてPull Requestを作成
   - レビューを受ける
   - 承認後にマージ

3. **ブランチ名の規則**
   - `feature/` - 新機能開発
   - `bugfix/` - バグ修正
   - `hotfix/` - 緊急修正
   - 小文字、ハイフン区切りを使用

### コミットメッセージ規約
```
<type>: <subject>

[optional body]
```

**Type一覧:**
- `feat`: 新機能追加
- `fix`: バグ修正
- `docs`: ドキュメントのみの変更
- `style`: コードの意味に影響しない変更（空白、フォーマット等）
- `refactor`: バグ修正や機能追加を伴わないコード変更
- `test`: テストの追加・修正
- `chore`: ビルドプロセスやツールの変更

## 3. 開発フロー

### 作業開始前
1. mainブランチを最新に更新
   ```bash
   git checkout main
   git pull origin main
   ```
2. GitHub Issueを確認し、作業内容と優先度を把握
   ```bash
   gh issue list
   ```
3. 関連ドキュメントを確認（CLAUDE.md、各種仕様書）
4. TodoListで作業計画を作成・管理
5. 必要なドキュメントを参照

### 作業中の確認事項
- **疑問がある場合は立ち止まる**: ドキュメントの内容に矛盾や不明確な点があれば、実装前に確認
- **引き継ぎ内容の検証**: 引き継がれた情報が現在のプロジェクトに適合するか確認
- **コンテキストの確認**: 旧プロジェクトのルールを新プロジェクトに適用する前に妥当性を確認
- **動作確認を必ず実施**: 実装後は必ず実際の動作を確認（視覚的確認が難しい場合は数値モニタリング）

### 実装時の原則
1. **既存コードの活用**
   - `/old_project_achive/testAction/` のロジックを参考に
   - 描画部分のみCanvas対応に変更
   
2. **段階的な実装**
   - 小さな単位で実装・動作確認
   - 各フェーズごとにテストを実施

3. **品質チェック**
   - 定期的に `npm run lint` を実行
   - テストが存在する場合は `npm test` を実行

### 作業完了時
1. lintエラーがないことを確認
   ```bash
   npm run lint
   ```
2. 自動テストを実行
   ```bash
   npm run test:simple  # 基本的なチェック
   node tests/puppeteer/test-gameplay.js  # ゲームプレイテスト
   ```
3. 基本動作確認を実施
   - テストが成功することを確認
   - 開発サーバーで実際の動作を確認（必須）
   - 新機能が正しく動作することを確認
   - 既存機能に影響がないことを確認
   - ブラウザコンソールにエラーがないことを確認
4. TodoListを更新
5. **引き継ぎ前の必須確認**
   - すべてのテストがPASSすること
   - 実装した機能が動作すること
   - エラーがないこと
6. GitHub Copilotレビューの指摘を確認・対応

## 4. ファイル管理の原則

### ファイル作成・編集のルール
- **最小限の原則**: 必要最小限のファイルのみ作成
- **既存優先**: 既存ファイルの編集を優先

### 禁止事項
- 不要なコメントの追加（詳細は「コメントに関するルール」参照）
- セキュリティを損なうコードの実装
- 秘密情報のハードコーディング
- 絵文字の使用（明示的な要求時を除く）

## 4-1. コメントに関するルール

### 基本方針
- **実装内の説明的なコメントは原則書かない**
- コードは自己文書化を心がけ、変数名・関数名で意図を表現する

### 許可されるコメント
1. **JSDocコメント**
   - ファイルレベルの説明
   - クラス・関数のドキュメント
   - パラメータと戻り値の型情報

2. **複雑なロジックの説明**
   - アルゴリズムが複雑で、コードだけでは理解困難な場合
   - 特殊な計算式や物理演算の説明
   - パフォーマンス最適化のための特殊な実装

3. **TODOコメント**
   - 将来の改善点や未実装機能の記録

### 禁止されるコメント
- コードの動作をそのまま説明するコメント（例：`// カウンタを増やす`）
- 変数名から明らかな内容の説明（例：`// プレイヤーの位置` before `player.x`）
- JSDocと重複する内容

### 例

**良い例**:
```typescript
/**
 * プレイヤーキャラクターを制御するクラス
 */
export class Player extends Entity {
    // TODO: ダッシュ機能を実装
    
    // ジャンプ力の計算式：初速度 = sqrt(2 * 重力 * 最大高さ)
    const jumpPower = Math.sqrt(2 * this.gravity * MAX_JUMP_HEIGHT);
}
```

**悪い例**:
```typescript
export class Player extends Entity {
    // プレイヤーのX座標
    this.x = x;
    
    // 右に移動
    this.x += speed;
    
    // ジャンプ処理
    jump(): void {
        // 速度を上向きに設定
        this.vy = -12;
    }
}
```

## 5. 実装ミスを防ぐためのルール

### 5.1 事前確認
- 新しいメソッドを使う前に、そのメソッドが存在するか確認する
- `grep -r "methodName" src/` で使用例を確認
- クラスのソースコードを直接確認

### 5.2 防御的プログラミング
```typescript
// メソッドの存在チェック
if (renderer.hasSprite && !renderer.hasSprite(key)) {
    // フォールバック処理
}

// オプショナルチェイニング
const value = obj?.property?.method?.();

// デフォルト値
const items = state.items || [];

// TypeScriptの型ガード
if (entity instanceof Player) {
    // Player固有のメソッドを安全に呼び出し
    entity.jump();
}
```

### 5.3 エラーハンドリング
- 非同期処理には必ず`.catch()`を追加
- try-catchでクリティカルな処理を保護
- エラー時のフォールバック処理を実装

### 5.4 影響範囲の確認
- 変更前に関連ファイルをリストアップ
- 変更後に`npm run lint`でエラーチェック
- コンソールエラーが出ていないか確認

### 5.5 ドキュメント参照
- `docs/IMPLEMENTATION_CHECKLIST.md`を作業前に確認
- 既存の実装パターンを参考にする

## 6. SVG→Canvas移植の方針

### 変換ガイドライン
| SVGベース | Canvasベース |
|-----------|--------------|
| SVG要素操作 | Canvas API描画 |
| CSSアニメーション | JavaScriptアニメーション |
| DOMイベント | Canvas座標計算 |

### 再利用可能な要素
- ゲームロジック（物理演算、衝突判定）
- ゲーム状態管理
- レベルデータ構造
- 音声管理システム

## 7. 開発環境

### 必要なツール
- Node.js 16+
- npm
- Git
- テキストエディタ（VSCode推奨）

### 開発サーバー
```bash
npm run dev    # Vite開発サーバー起動
```

## 8. コードレビューとフィードバック

### GitHub Copilotレビューへの対応
- PRに対するCopilotの自動レビュー指摘事項を確認
- 妥当な指摘については修正を実施
- セキュリティ、パフォーマンス、コード品質の改善提案を積極的に採用
- 指摘が不適切な場合は、理由を明確にしてスキップ可能

### Copilotコメントの確認方法
Copilotのレビューコメントは複数の場所に表示される可能性があります：

1. **通常のPRコメント確認**
   ```bash
   gh pr view --comments
   ```

2. **レビューコメントの確認（スレッド形式）**
   ```bash
   gh api repos/becky3/coin-hunter-adventure-pixel/pulls/[PR番号]/comments
   ```

3. **レビュー情報の確認**
   ```bash
   gh pr view [PR番号] --json reviews --jq '.reviews[]'
   ```

4. **Web UI での確認**
   - PR画面の「Files changed」タブでインラインコメントを確認
   - 「Conversation」タブで全体のコメントを確認
   - 低信頼度で非表示になっているコメントも「Show resolved」で確認

### レビュー対応の優先順位
1. **高優先度**: セキュリティ問題、バグ、メモリリーク
2. **中優先度**: パフォーマンス最適化、コード品質
3. **低優先度**: コードスタイル、命名規則

## 8. テスト・デバッグ

### 動作確認の手順
1. **Puppeteerテストによる自動確認**（開発者が実行）
   ```bash
   npm test  # 軽量版テスト
   # または特定機能のテスト
   node tests/puppeteer/test-gameplay.js
   ```
2. **テスト用スクリプトの作成**
   - 実装した機能に対応するPuppeteerテストを作成
   - 直接的なJavaScript操作でゲーム状態を検証
3. **視覚的確認が必要な場合**
   - スクリーンショット機能を使用
   - 数値モニタリングで状態を確認

### 基本的な確認項目
- [ ] 60FPSでの安定動作
- [ ] 基本的な入力応答
- [ ] メモリリークがないこと
- [ ] エラーが発生しないこと
- [ ] アセットが正しく読み込まれていること
- [ ] レンダリングが正常に行われていること

### デバッグ方法
- ブラウザの開発者ツールを活用
- `console.log` は開発中のみ使用可
- パフォーマンスプロファイラーで最適化
- デバッグ用HTMLファイルの作成（必要に応じて）

### テストツール
- **Puppeteerテスト**: `tests/puppeteer/`ディレクトリ
- **スクリーンショットユーティリティ**: `tests/puppeteer/utils/screenshot.js`
- **数値モニタリング**: 視覚的確認が難しい場合に使用
- **テスト実行例**:
  ```bash
  node tests/puppeteer/test-gameplay.js
  node tests/puppeteer/test-jump-tracking.js
  ```

## 9. 参考資料

### プロジェクトドキュメント
- ゲーム仕様: `docs/GAME_SPECIFICATION.md`
- 技術仕様: `docs/TECHNICAL_SPECIFICATION.md`
- 実装ロードマップ: `docs/IMPLEMENTATION_ROADMAP.md`

### 元プロジェクト
- 参照先: `/old_project_achive/testAction/`
- 特に `src/` ディレクトリのゲームロジックを参考に

## 10. 引き継ぎ資料の作成

### 作成タイミング
- 重要な機能の実装完了時
- 大きな問題解決の後
- ユーザーから要請があった時

### ファイル名規則
```
handover-docs/YYYY-MM-DD_作業内容.md
例: handover-docs/2025-06-25_level-loader-implementation.md
```

### 必須記載事項
1. **作業概要**
   - 実装した機能
   - 解決した問題
   - 変更した箇所

2. **技術的詳細**
   - 採用したアプローチとその理由
   - 直面した課題と解決方法
   - 今後の改善点

3. **注意事項**
   - 既知の問題
   - 今後必要な作業
   - 依存関係

4. **作業の感想**（必須）
   - 良かった点
   - 困難だった点
   - 学んだこと

5. **ユーザーへの要望**（必須）
   - 改善してほしい点を忌憚なく記載
   - より効率的に作業するための提案
   - プロジェクト運営への提案

6. **今回実施した改善**（あれば）
   - 効率化したプロセス
   - 追加したツールや機能
   - ドキュメントの改善点

7. **今後の改善提案**（あれば）
   - 実装はしていないが有効と思われるアイデア
   - 長期的に取り組むべき課題
   - アーキテクチャレベルの提案

## 8. テスト作成方針

### 8.1 基本方針
- **統合的なテストファイルを優先**
  - 個別の問題確認のために毎回新しいテストファイルを作成しない
  - 一つの統合テストファイルから複数のテストケースを実行できる構造にする

### 8.2 テストファイルの構成
1. **interactive-test.cjs** - 手動デバッグ用
   - メニュー形式で様々なテストを選択実行
   - 問題の詳細な調査用

2. **automated-test.cjs** - CI/CD用
   - 自動実行される基本的な動作確認
   - pre-pushフックで使用

### 8.3 新しいテストが必要な場合
- まず既存のテストファイルに組み込めないか検討
- 単発の確認作業は一時的なファイルとして作成し、確認後は削除
- 恒久的に必要なテストのみ統合テストに追加